// This was originally copied from: https://github.com/alexnask/iguanaTLS/blob/master/src/pcks1-1_5.zig
const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;
const crypto = std.crypto;
const tls = crypto.tls;
const bigint = std.math.big.int;

fn rsaPerform(
    allocator: Allocator,
    modulus: bigint.Const,
    exponent: bigint.Const,
    base: []const u8,
) !?bigint.Managed {
    // @TODO Better algorithm, make it faster.
    const curr_base_limbs = try allocator.alloc(
        usize,
        std.math.divCeil(usize, base.len, @sizeOf(usize)) catch unreachable,
    );
    const curr_base_limb_bytes = @as([*]u8, @ptrCast(curr_base_limbs))[0..base.len];
    mem.copyForwards(u8, curr_base_limb_bytes, base);
    mem.reverse(u8, curr_base_limb_bytes);
    var curr_base = (bigint.Mutable{
        .limbs = curr_base_limbs,
        .positive = true,
        .len = curr_base_limbs.len,
    }).toManaged(allocator);
    defer curr_base.deinit();

    var curr_exponent = try exponent.toManaged(allocator);
    defer curr_exponent.deinit();
    var result = try bigint.Managed.initSet(allocator, @as(usize, 1));

    // encrypted = signature ^ key.exponent MOD key.modulus
    while (curr_exponent.toConst().orderAgainstScalar(0) == .gt) {
        if (curr_exponent.isOdd()) {
            try result.ensureMulCapacity(result.toConst(), curr_base.toConst());
            try result.mul(&result, &curr_base);
            try llmod(&result, modulus);
        }
        try curr_base.sqr(&curr_base);
        try llmod(&curr_base, modulus);
        try curr_exponent.shiftRight(&curr_exponent, 1);
    }

    if (result.limbs.len * @sizeOf(usize) < base.len)
        return null;
    return result;
}

// res = res mod N
fn llmod(res: *bigint.Managed, n: bigint.Const) !void {
    var tmpn = try n.toManaged(res.allocator);
    defer tmpn.deinit();
    var temp = try bigint.Managed.init(res.allocator);
    defer temp.deinit();
    try temp.divTrunc(res, res, &tmpn);
}

fn algorithmPrefix(signature_scheme: tls.SignatureScheme) []const u8 {
    // reference: https://datatracker.ietf.org/doc/html/rfc8017#section-9.2
    return switch (signature_scheme) {
        .rsa_pkcs1_sha1 => &[_]u8{
            0x30, 0x21, 0x30, 0x09, 0x06,
            0x05, 0x2b, 0x0e, 0x03, 0x02,
            0x1a, 0x05, 0x00, 0x04, 0x14,
        },
        // .sha224 => &[_]u8{
        //     0x30, 0x2d, 0x30, 0x0d, 0x06,
        //     0x09, 0x60, 0x86, 0x48, 0x01,
        //     0x65, 0x03, 0x04, 0x02, 0x04,
        //     0x05, 0x00, 0x04, 0x1c,
        // },
        .rsa_pkcs1_sha256 => &[_]u8{
            0x30, 0x31, 0x30, 0x0d, 0x06,
            0x09, 0x60, 0x86, 0x48, 0x01,
            0x65, 0x03, 0x04, 0x02, 0x01,
            0x05, 0x00, 0x04, 0x20,
        },
        .rsa_pkcs1_sha384 => &[_]u8{
            0x30, 0x41, 0x30, 0x0d, 0x06,
            0x09, 0x60, 0x86, 0x48, 0x01,
            0x65, 0x03, 0x04, 0x02, 0x02,
            0x05, 0x00, 0x04, 0x30,
        },
        .rsa_pkcs1_sha512 => &[_]u8{
            0x30, 0x51, 0x30, 0x0d, 0x06,
            0x09, 0x60, 0x86, 0x48, 0x01,
            0x65, 0x03, 0x04, 0x02, 0x03,
            0x05, 0x00, 0x04, 0x40,
        },
        else => unreachable,
    };
}

fn SchemeHash(comptime scheme: tls.SignatureScheme) type {
    return switch (scheme) {
        .rsa_pkcs1_sha1 => crypto.hash.Sha1,
        .rsa_pkcs1_sha256 => crypto.hash.sha2.Sha256,
        .rsa_pkcs1_sha384 => crypto.hash.sha2.Sha384,
        .rsa_pkcs1_sha512 => crypto.hash.sha2.Sha512,
        else => @compileError("bad scheme"),
    };
}

pub fn verify(
    allocator: Allocator,
    signature_scheme: tls.SignatureScheme,
    signature: []const u8,
    verify_bytes: []const u8,
    modulus_bytes: []const u8,
    exponent_bytes: []const u8,
) !bool {
    const hash = switch (signature_scheme) {
        inline .rsa_pkcs1_sha1,
        .rsa_pkcs1_sha256,
        .rsa_pkcs1_sha384,
        .rsa_pkcs1_sha512,
        => |comptime_scheme| brk: {
            const Hash = SchemeHash(comptime_scheme);
            var h = Hash.init(.{});
            h.update(verify_bytes);
            break :brk h.finalResult()[0..];
        },
        else => unreachable,
    };

    const modulus = try parseInt(allocator, modulus_bytes);
    const exponent = try parseInt(allocator, exponent_bytes);
    defer allocator.free(modulus.limbs);
    defer allocator.free(exponent.limbs);

    // RSA hash verification with PKCS 1 V1_5 padding

    if (modulus.bitCountAbs() != signature.len * 8)
        return false;

    var rsa_result = (try rsaPerform(allocator, modulus, exponent, signature)) orelse return false;
    defer rsa_result.deinit();

    if (rsa_result.limbs.len * @sizeOf(usize) < signature.len)
        return false;

    const enc_buf = @as([*]u8, @ptrCast(rsa_result.limbs.ptr))[0..signature.len];
    mem.reverse(u8, enc_buf);

    if (enc_buf[0] != 0x00 or enc_buf[1] != 0x01)
        return false;
    if (!mem.endsWith(u8, enc_buf, hash))
        return false;
    const prefix = algorithmPrefix(signature_scheme);
    if (!mem.endsWith(u8, enc_buf[0 .. enc_buf.len - hash.len], prefix))
        return false;
    if (enc_buf[enc_buf.len - hash.len - prefix.len - 1] != 0x00)
        return false;
    for (enc_buf[2 .. enc_buf.len - hash.len - prefix.len - 1]) |c| {
        if (c != 0xff) return false;
    }

    return true;
}

pub fn verifyFixed(
    signature_scheme: tls.SignatureScheme,
    signature: []const u8,
    verify_bytes: []const u8,
    modulus_bytes: []const u8,
    exponent_bytes: []const u8,
) !void {
    // 11752 maximum alloc for 270 bytes in certificate public key
    // 23272 maximum alloc for 526 bytes certificate public key
    var buffer: [1024 * 24]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&buffer);
    const allocator = fba.allocator();

    if (!try verify(allocator, signature_scheme, signature, verify_bytes, modulus_bytes, exponent_bytes))
        return error.InvalidSignature;
}

fn parseInt(alloc: std.mem.Allocator, bytes: []const u8) !bigint.Const {
    const limb_count = std.math.divCeil(usize, bytes.len - 1, @sizeOf(usize)) catch unreachable;
    const limbs = try alloc.alloc(usize, limb_count);
    @memset(limbs, 0);
    var limb_ptr: [*]u8 = @ptrCast(limbs.ptr);
    @memcpy(limb_ptr[0..bytes.len], bytes);
    mem.reverse(u8, limb_ptr[0..bytes.len]);
    return bigint.Const{ .limbs = limbs, .positive = true };
}

test "verify signature" {
    const rsa = std.crypto.Certificate.rsa;
    const pk = try rsa.PublicKey.parseDer(&example.cert_pub_key);
    try verifyFixed(
        .rsa_pkcs1_sha256,
        &example.signature,
        &example.verify_bytes,
        pk.modulus,
        pk.exponent,
    );
}

const example = struct {
    const cert_pub_key = [_]u8{
        0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xd6, 0x23, 0xba, 0xa9, 0x36, 0x61, 0xcd,
        0x80, 0x28, 0x6e, 0xf4, 0x4f, 0xa8, 0x12, 0x1c, 0xa0, 0x72, 0x5b, 0x50, 0xa7, 0x46, 0x96, 0xba,
        0x70, 0xa1, 0xf2, 0xc7, 0x27, 0x00, 0xaf, 0xe1, 0xd1, 0xa0, 0x24, 0x12, 0x86, 0x3f, 0xb4, 0xc6,
        0x50, 0x6f, 0x86, 0x6b, 0x74, 0xc9, 0x7e, 0xbe, 0x4c, 0xf0, 0x2b, 0x05, 0xee, 0x23, 0x1c, 0xc0,
        0xe4, 0xeb, 0xd4, 0xe1, 0x88, 0x18, 0x80, 0x9a, 0x79, 0xf7, 0xe0, 0xda, 0x28, 0xab, 0xc9, 0x48,
        0xf4, 0xb6, 0x98, 0xc6, 0x7a, 0x37, 0x34, 0x0d, 0x37, 0xf7, 0x04, 0x49, 0x5e, 0x50, 0x08, 0x7f,
        0x51, 0x12, 0xbf, 0x3c, 0x21, 0x8c, 0x8c, 0x5c, 0x88, 0x05, 0x06, 0x2a, 0x0d, 0x67, 0xae, 0x21,
        0xe0, 0xab, 0xce, 0x47, 0x46, 0xb2, 0x0a, 0x40, 0x0e, 0xe7, 0x69, 0x97, 0x91, 0x86, 0xab, 0x20,
        0xbf, 0x6d, 0x02, 0xb2, 0x17, 0xba, 0xf3, 0x5e, 0x90, 0x5e, 0xb5, 0x07, 0x7b, 0xb5, 0x23, 0xb0,
        0x64, 0x44, 0xe4, 0xde, 0x02, 0x08, 0x76, 0x6c, 0xad, 0xf5, 0xcc, 0x79, 0xda, 0x86, 0x86, 0x6c,
        0x42, 0x52, 0x66, 0x56, 0xfd, 0x06, 0x6a, 0x4d, 0x44, 0xb6, 0xb6, 0x8e, 0xdf, 0x45, 0x84, 0x43,
        0x95, 0x3f, 0xb2, 0xc3, 0x05, 0x46, 0x9b, 0x57, 0xa5, 0xca, 0x17, 0x92, 0x41, 0xdf, 0x78, 0x32,
        0x20, 0xfd, 0x23, 0x13, 0xd6, 0xd0, 0x97, 0xbc, 0x41, 0x6b, 0x4e, 0xe8, 0x95, 0x4c, 0x77, 0x4e,
        0x66, 0x36, 0x24, 0xe3, 0xde, 0x5c, 0x5c, 0x4a, 0x96, 0x73, 0x21, 0xe8, 0xe8, 0x04, 0x45, 0x66,
        0x0a, 0x98, 0x3f, 0xb7, 0x3c, 0x67, 0x1b, 0xef, 0x3c, 0xbb, 0xce, 0x77, 0x7f, 0xbd, 0xeb, 0xa8,
        0x66, 0x87, 0xe8, 0xc9, 0xbb, 0xcd, 0x3f, 0xda, 0x4d, 0xd8, 0xee, 0xc9, 0xbe, 0xe6, 0x7a, 0x24,
        0x08, 0x2e, 0xa7, 0xfa, 0xe9, 0xfb, 0x28, 0x64, 0x13, 0x02, 0x03, 0x01, 0x00, 0x01,
    };
    const signature = [_]u8{
        0x2f, 0x6c, 0x15, 0x33, 0x7f, 0x3d, 0x77, 0xa8, 0xe9, 0x7d, 0x5c, 0x9e, 0xef, 0x1b, 0x88, 0xa1,
        0x83, 0x01, 0x6b, 0xac, 0x74, 0x78, 0x68, 0xb7, 0x95, 0x22, 0x5e, 0x5d, 0xe4, 0xb9, 0x47, 0x3f,
        0x6a, 0x0d, 0x2e, 0x24, 0xb0, 0x94, 0x50, 0xd7, 0x44, 0xb6, 0xaa, 0xb1, 0xa8, 0x36, 0xc9, 0xc4,
        0x98, 0xe7, 0x26, 0x5e, 0x29, 0xb5, 0x44, 0x90, 0xf9, 0x3c, 0x7a, 0x66, 0xd3, 0x6f, 0x40, 0x47,
        0xf6, 0xe1, 0x49, 0x22, 0xe5, 0x47, 0x34, 0xf7, 0xad, 0xb9, 0x18, 0x7a, 0x69, 0x19, 0xb8, 0xaf,
        0xfd, 0x84, 0xf1, 0x95, 0x48, 0xb0, 0xe2, 0x70, 0x6f, 0xe4, 0x73, 0x1c, 0xeb, 0x98, 0x91, 0xb0,
        0x35, 0x46, 0x08, 0x3e, 0x66, 0x69, 0xae, 0x3d, 0x53, 0x67, 0x8f, 0x06, 0x1f, 0xc4, 0x9b, 0xd0,
        0x4e, 0x39, 0xfe, 0x71, 0xd1, 0xb6, 0x99, 0xdd, 0xe9, 0xd5, 0x23, 0x5c, 0x0c, 0xb9, 0x2a, 0xf4,
        0x42, 0x5b, 0x66, 0x53, 0x5a, 0x24, 0x61, 0x1e, 0x0c, 0xc3, 0x65, 0x6a, 0xb6, 0x0e, 0x6a, 0xa2,
        0x5f, 0xd8, 0xc3, 0x4c, 0x3c, 0xbd, 0xf4, 0x60, 0x2a, 0x0a, 0x33, 0x88, 0xa8, 0xd1, 0x58, 0xb6,
        0xc8, 0x47, 0x6a, 0xd2, 0xa1, 0x35, 0x6a, 0xd6, 0x6d, 0xce, 0x9f, 0xe4, 0x12, 0xba, 0xd8, 0xfc,
        0xd8, 0xb8, 0x65, 0xd6, 0x9d, 0x0d, 0xaa, 0xac, 0xb6, 0xb8, 0x99, 0xc7, 0x5a, 0x8a, 0xc8, 0x8b,
        0xca, 0xe2, 0xd8, 0xa5, 0xab, 0x9b, 0xc8, 0xeb, 0xd2, 0x67, 0xe5, 0x91, 0xcf, 0xb1, 0x8c, 0xd1,
        0x6a, 0xeb, 0x49, 0xef, 0xa4, 0x5e, 0x3c, 0x4b, 0xe9, 0x29, 0x86, 0x6e, 0xe2, 0xc2, 0x76, 0xd9,
        0xbe, 0xec, 0xd0, 0x80, 0xf5, 0x61, 0x22, 0x4b, 0x55, 0xb6, 0x7c, 0x22, 0xa9, 0x5e, 0xf3, 0x74,
        0x7c, 0x4c, 0xb2, 0x90, 0x8e, 0x24, 0xe9, 0xe9, 0x24, 0xac, 0x05, 0xa7, 0xf6, 0x13, 0x36, 0xe0,
    };
    const verify_bytes = [_]u8{
        0xd4, 0x80, 0xa2, 0x46, 0x70, 0x77, 0x1b, 0xb8, 0xe1, 0x81, 0x8b, 0x19, 0x33, 0x47, 0xc8, 0x55,
        0xc4, 0xef, 0x24, 0xac, 0x1e, 0x9d, 0xf3, 0xea, 0x5f, 0x24, 0xfd, 0x28, 0x66, 0x6f, 0xfc, 0xca,
        0xab, 0x89, 0x39, 0x6c, 0xf5, 0x4d, 0x24, 0xdb, 0x65, 0x21, 0x3f, 0x7f, 0xc5, 0xc9, 0x85, 0x12,
        0x24, 0x4e, 0x83, 0x3b, 0x9f, 0x46, 0x73, 0xc6, 0xe2, 0xd8, 0xf8, 0xb9, 0xc5, 0x17, 0x82, 0x07,
        0x03, 0x00, 0x17, 0x41, 0x04, 0x8e, 0x14, 0x33, 0xbe, 0x95, 0x3c, 0x72, 0x25, 0x0b, 0x58, 0x40,
        0x01, 0x79, 0xe7, 0x66, 0x5a, 0x44, 0x3f, 0x76, 0x74, 0x77, 0x99, 0x52, 0xbe, 0xc9, 0xa4, 0x7d,
        0xc9, 0x66, 0x62, 0xe6, 0x59, 0x07, 0xc8, 0x8c, 0x26, 0x73, 0xa4, 0x91, 0x15, 0xb5, 0x0b, 0xcb,
        0x89, 0xc3, 0x30, 0xf6, 0x0f, 0x5a, 0xde, 0x82, 0x4d, 0x25, 0x59, 0x9e, 0x6d, 0x57, 0xa1, 0xee,
        0x9c, 0x4c, 0x74, 0x15, 0x42,
    };
};
